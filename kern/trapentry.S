/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>
#include <kern/macro.h>

#include <kern/picirq.h>


###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushq $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushq $0;							\
	pushq $(num);							\
	jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */
/* jchung: define each of the vectors for handling T_XXes defined at inc/trap.h
 * jchung: IDT vectors defined by processor (0-31) are as follows:
 * #define T_DIVIDE     0		// divide error
 * #define T_DEBUG      1		// debug exception
 * #define T_NMI        2		// non-maskable interrupt
 * #define T_BRKPT      3		// breakpoint
 * #define T_OFLOW      4		// overflow
 * #define T_BOUND      5		// bounds check
 * #define T_ILLOP      6		// illegal opcode
 * #define T_DEVICE     7		// device not available
 * #define T_DBLFLT     8		// double fault
 * //#define T_COPROC   9	    // reserved (not generated by recent processors)
 * #define T_TSS       10		// invalid task switch segment
 * #define T_SEGNP     11		// segment not present
 * #define T_STACK     12		// stack exception
 * #define T_GPFLT     13		// general protection fault
 * #define T_PGFLT     14		// page fault
 * //#define T_RES     15	    // reserved
 * #define T_FPERR     16		// floating point error
 * #define T_ALIGN     17		// aligment check
 * #define T_MCHK      18		// machine check
 * #define T_SIMDERR   19		// SIMD floating point error
 * #define T_SYSCALL   48		// system call
 * #define T_DEFAULT   500		// catchall
 * jchung: whether each of the vector has an error code or not was checked by referring to:
 * https://casys-kaist.github.io/jos/ref/i386/s09_10.htm    (for codes 01-16)
 * https://wiki.osdev.org/Exceptions                        (for codes 17-19)
 * TODO: check whether codes 48 and 500 use error codes or not
 */
    TRAPHANDLER_NOEC(XTRAPX_DIVIDE, T_DIVIDE)
    TRAPHANDLER_NOEC(XTRAPX_DEBUG, T_DEBUG)
    TRAPHANDLER_NOEC(XTRAPX_NMI, T_NMI)
    TRAPHANDLER_NOEC(XTRAPX_BRKPT, T_BRKPT)
    TRAPHANDLER_NOEC(XTRAPX_OFLOW, T_OFLOW)
    TRAPHANDLER_NOEC(XTRAPX_BOUND, T_BOUND)
    TRAPHANDLER_NOEC(XTRAPX_ILLOP, T_ILLOP)
    TRAPHANDLER_NOEC(XTRAPX_DEVICE, T_DEVICE)
    TRAPHANDLER(XTRAPX_DBLFLT, T_DBLFLT)
    /*TRAPHANDLER_NOEC(XTRAPX_COPROC, T_COPROF)*/
    TRAPHANDLER(XTRAPX_TSS, T_TSS)
    TRAPHANDLER(XTRAPX_SEGNP, T_SEGNP)
    TRAPHANDLER(XTRAPX_STACK, T_STACK)
    TRAPHANDLER(XTRAPX_GPFLT, T_GPFLT)
    TRAPHANDLER(XTRAPX_PGFLT, T_PGFLT)
    /*TRAPHANDLER_NOEC(XTRAPX_RES, T_RES)*/
    TRAPHANDLER_NOEC(XTRAPX_FPERR, T_FPERR)
    TRAPHANDLER(XTRAPX_ALIGN, T_ALIGN)
    TRAPHANDLER_NOEC(XTRAPX_MCHK, T_MCHK)
    TRAPHANDLER_NOEC(XTRAPX_SIMDERR, T_SIMDERR)
    TRAPHANDLER_NOEC(XTRAPX_SYSCALL, T_SYSCALL)
    TRAPHANDLER_NOEC(XTRAPX_DEFAULT, T_DEFAULT)
/*
 * Lab 3: Your code here for _alltraps
 *
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
/* jchung: order of implementation provided in document:
 * 1. push values to make the stack look like a struct Trapframe
 * 2. load GD_KD into %ds and %es
 * 3. pass a pointer to the Trapframe as an argument to trap() (Hint: Review the x64 calling convention from lab 1)
 * 4. call trap (can trap ever return?)
 */
_alltraps:
    /* because we will be polluting %es and %ds */
    /* jchung: for some reason, 'pushq %ds' and 'pushq %es' don't work? */
    #pushq %ds
    #pushq %es
    subq $16, %rsp
    movw %ds, 8(%rsp)
    movw %es, 0(%rsp)
    /* 1. push values to make the stack look like a struct Trapframe */
    PUSHA
    /* 2. load GD_KD into %ds and %es */
    /* jchung: for some reason, 'movq $GD_KD, %ds' and 'movq $GD_KD, %es' don't work? */
    #movq $GD_KD, %ds
    #movq $GD_KD, %es
    movq $GD_KD, %r15
    movq %r15, %ds
    movq %r15, %es
    /* 3. pass a pointer to the Trapframe as an argument to trap() */
    movq %rsp, %rdi
    /* 4. call trap */
    call trap
    /* does trap return? */
    /* jchung: IDK, but return things as they were before */
    POPA_
    #popq %es
    #popq %ds
    movw 0(%rsp), %ds
    movw 8(%rsp), %es
    addq $16, %rsp
    iret

